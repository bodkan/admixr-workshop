---
title: Demo tutorial
output: github_document
---

```{r setup, include = F}
knitr::opts_chunk$set(echo = T, eval = T)
```


## Introduction

Lets load all pre-requisites first. You should first try to install them by running `install.packages(c("admixr", "tidyverse"))`. Note that this make take a long time because there are a lots of C/C++ dependencies which need to be compiled first (on a freshly installed system, this could easily take 20 minutes).

```{r}
library(admixr)
library(tidyverse)
```

## Demo #1

#### EIGENSTRAT file format

Let's direct _admixr_ to the location of the EIGENSTRAT trio data files. Note that this doesn't load any data! It just creates "pointers" to where the data files are located on your disk.s

```{r}
prefix <- file.path(getwd(), "dataset")

data <- eigenstrat(prefix)

data
```

Each EIGENSTRAT data set has three components: a trio of `ind/snp/geno` files, which can be loaded with `read_*()` functions:

- `ind` file:

```{r}
ind <- read_ind(data)
ind
```

- `snp` file:

```{r}
snp <- read_snp(data)
snp

nrow(snp) / 1e6 # how many millions of sites we have genotyped?
```

- `geno` file:

```{r}
geno <- read_geno(data)
geno
```

We can see that the only genotypes present are reference and alternative homozygotes. There are no heterozygous sites in our demo data because all genomes have been pseudo-haplodized (at each heterozygous position, a random allele was drawn from the two alleles present). In other cases, allele types 0, 1, and 2 would be present.

```{r}
table(geno$I0876) # Kostenki-14
table(geno$Vindija)
```

Every function in _admixr_ works with the EIGENSTRAT trio and the `eigenstrat()` function provided by the package makes this easier by tracking where those files are and keeping them in one place in memory.

Note: in case you want to generate your own EIGENSTRAT data (from VCF files, etc.) or if you want to somehow process or filter data you already have, functions `write_snp/write_ind/write_geno` can be very useful.

## Demo #2

```{r}
na.omit(geno[, c("Dinka", "Yoruba", "Vindija", "Chimp")])
```


```{r}
f4_result1 <- f4(
  W = "Dinka", X = "Yoruba", Y = "Vindija", Z = "Chimp",
  data = data
)

f4_result1
```



```{r}
f4_result2 <- f4(
  W = "Dinka", X = "French", Y = "Vindija", Z = "Chimp",
  data = data
)

f4_result2
```


### Homebrew $f_4$ statistic (and _D_ statistic)

```{r}
# subset to only four columns, for brevity
gt <- geno[, c("Dinka", "Yoruba", "Vindija", "Chimp")]

# detect two kinds of site patterns
baba <- with(gt, Dinka == Vindija & Yoruba == Chimp & Vindija != Chimp)
abba <- with(gt, Dinka == Chimp & Yoruba == Vindija & Vindija != Chimp)

# count the two site patterns
(total_baba <- sum(baba, na.rm = T))
(total_abba <- sum(abba, na.rm = T))
```

D statistic:

```{r}
(total_baba - total_abba) / (total_baba + total_abba)
```

$f_4$ statistic:

```{r}
(total_baba - total_abba) / nrow(na.omit(gt))
```

Of course, this doesn't give us Z-scores (p-values) and so we can't determine significance (although we could easily add that too) but it servers as a useful demonstration that ADMIXTOOLS, $f$-statistics, _admixr_ and other tools are not black boxes built on high-level techniques. In the end, they all boil down to this kind of calculation.

## Demo #3 - $f_4$-ratio statistic

